[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Luiz H. Barbosa F.",
    "section": "",
    "text": "Sou Cientista de Dados, focado em dados econômicos, financeiros e contábeis. Gosto bastante de analisar dados e descobrir fatos.\nGraduei em Bacharelado Interdisciplinar em Ciência e Economia e Ciências Contábeis pela Universidade Federal de Alfenas. Me especializei nos uso das linguagens R e Python, e me dediquei em construir códigos voltados à métodos quantitativos aplicados em economia, finanças e negócios, com ênfase em análises de séries temporais, previsões e inferência causal.\nHoje trabalho na Análise Macro, auxiliando mais de 4000 alunos com dúvidas teóricas e práticas do cotidiano de data science, bem como tutor em mais de 5 cursos.\nMeu objetivo é me comparar com meu eu do passado a cada mês, buscando sempre adquirir mais conhecimento.\nAtualmente estou focado em LLMs e conceitos matemáticos/estatísticos de modelos de machine learning."
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html",
    "href": "blog/2024-02-28-curva-is/index.html",
    "title": "Como construir uma Curva IS no Python?",
    "section": "",
    "text": "O objetivo do exercício será estimar uma versão da Curva IS do Modelo Semiestrutural de Pequeno Porte do BCB descrito nesse Relatório, conforme descrito abaixo:\n\\[\\begin{align}\nh_t = \\beta_0 + \\sum_{i&gt;0} \\beta_{1i} h_{t-1} + \\sum_{j&gt;0} \\beta_{2j} r_{t-j} +\\sum_{k &gt; 0} \\beta_{3k} \\Delta sup_{t-k} + u_t\n\\end{align}\\]\nBasicamente, a Curva IS estimada irá descrever a dinâmica do hiato do produto com base em suas próprias defasagens, da taxa de juros real ex-ante e da variação do superávit primário."
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#dados",
    "href": "blog/2024-02-28-curva-is/index.html#dados",
    "title": "Como construir uma Curva IS no Python?",
    "section": "Dados",
    "text": "Dados\nO Hiato do produto é aquele construído pelo Banco Central, disponibilizado nos anexos estatísticos do Relatório de Inflação.\nO hiato do juros é criado pela diferença entre o juros real ex-ante e o juro neutro, a taxa de juros real obtida pela taxa de juros nominal swap pré-DI de 360 dias deflacionada pela expectativa de inflação relativa ao período de vigência do contrato, o juro de equilíbrio segue uma proxy definida no Relatório de Inflação de dezembro de 2019, dada pela Selic esperada para t+3 deflacionada pela inflação espera para t+3.\nA variação do superávit primário utilizada é aquela proveniente do resultado fiscal estrutural construído pela SPE."
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#como-estimamos-a-curva-is",
    "href": "blog/2024-02-28-curva-is/index.html#como-estimamos-a-curva-is",
    "title": "Como construir uma Curva IS no Python?",
    "section": "Como estimamos a curva IS?",
    "text": "Como estimamos a curva IS?\nA Curva IS é estimada com base na equação descrita no início usando 2SLS com matriz de covariância robusta para evitar problemas na inferência dos parâmetros causados por autocorrelação e heterocedasticidade nos resíduos. Há também a adição de duas dummies para levar em consideração a crise de 2008 e a pandemia de Covid.\n\n\nCódigo\nfrom plotnine import *\nfrom bcb import sgs # Importar dados do SGS\nfrom bcb import Expectativas # Importar dados de Expectativas\nimport ipeadatapy as ip # importa dados do IPEADATA\nimport pandas as pd # Manipulação de dados\nimport numpy as np # Manipulação e cálculo de dados\nfrom functools import reduce # módulo para juntar dfs\nfrom datetime import datetime # módulo para trabalhar com data\nfrom linearmodels.iv import IV2SLS # Modelo IV2SLS\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set()"
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#hiato-do-produto",
    "href": "blog/2024-02-28-curva-is/index.html#hiato-do-produto",
    "title": "Como construir uma Curva IS no Python?",
    "section": "2.1 Hiato do Produto",
    "text": "2.1 Hiato do Produto\n\n\nCódigo\n# Coleta e tratamento do Hiato do Produto da IFI\nhiato = (\n    pd.read_excel(\n    \"https://www12.senado.leg.br/ifi/dados/arquivos/estimativas-do-hiato-do-produto-ifi/@@download/file/Hiato%20do%20Produto%20IFI.xlsx\",\n    sheet_name = \"Hiato do Produto\",\n    skiprows = 1\n    )\n    .assign(date_quarter = lambda x: pd.PeriodIndex(x['Trim-Ano'], freq = 'Q'),\n            hiato_ifi = lambda x: x.Hiato.astype(float) * 100)\n    .loc[:, ['date_quarter', 'hiato_ifi']]\n  )\n\n\n\n\nCódigo\nhiato\n\n\n\n\n\n\n\n\n\n\ndate_quarter\nhiato_ifi\n\n\n\n\n0\n1996Q1\n-0.86\n\n\n1\n1996Q2\n-0.71\n\n\n2\n1996Q3\n0.73\n\n\n3\n1996Q4\n0.02\n\n\n4\n1997Q1\n0.19\n\n\n...\n...\n...\n\n\n107\n2022Q4\n0.10\n\n\n108\n2023Q1\n0.56\n\n\n109\n2023Q2\n0.96\n\n\n110\n2023Q3\n0.76\n\n\n111\n2023Q4\n0.47\n\n\n\n\n112 rows × 2 columns\n\n\n\n\n\n\nCódigo\n# Coleta e tratamento do Hiato do Produto do BC\nhiato_bcb = (\n    pd.read_excel(\n    \"https://www.bcb.gov.br/content/ri/relatorioinflacao/202403/ri202403anp.xlsx\",\n    sheet_name = \"Graf 2.2.4\",\n    skiprows = 8\n    )\n    .assign(date_quarter = lambda x: pd.PeriodIndex(x['Trimestre'], freq = 'Q'),\n            hiato_bcb = lambda x: x.Hiato.astype(float))\n    .loc[:, ['date_quarter', 'hiato_bcb']]\n  )\n\nhiato_bcb\n\n\n\n\n\n\n\n\n\n\ndate_quarter\nhiato_bcb\n\n\n\n\n0\nNaT\nNaN\n\n\n1\n2003Q4\n-0.83\n\n\n2\n2004Q1\n-0.40\n\n\n3\n2004Q2\n-0.03\n\n\n4\n2004Q3\n0.35\n\n\n...\n...\n...\n\n\n78\n2023Q1\n-0.61\n\n\n79\n2023Q2\n-0.64\n\n\n80\n2023Q3\n-0.66\n\n\n81\n2023Q4\n-0.60\n\n\n82\n2024Q1\n-0.61\n\n\n\n\n83 rows × 2 columns"
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#resultado-estrutural-do-setor-público",
    "href": "blog/2024-02-28-curva-is/index.html#resultado-estrutural-do-setor-público",
    "title": "Como construir uma Curva IS no Python?",
    "section": "2.2 Resultado estrutural do setor público",
    "text": "2.2 Resultado estrutural do setor público\n\n\nCódigo\n# Coleta e tratamento do resultado estrutural do setor público\nsup = (\n     pd.read_excel(\n    \"https://www.gov.br/fazenda/pt-br/assuntos/politica-fiscal/atuacao-spe/resultado-fiscal-estrutural/tabelas-de-dados/series-historicas-rfe-2023-2022-versao-final.xlsx\",\n    sheet_name = \"RFE - Trimestral\",\n    skiprows = 1\n    )\n    .assign(date_quarter = lambda x: pd.PeriodIndex(\n            x['Acum. 4 Trimestres'].str.slice_replace(start = 4, stop = 5, repl = \"-Q\"),  freq = 'Q'\n            ),\n          sup = lambda x: (((x['Resultado Estrutural.2'].astype(float) + 1) ** (1/4)) - 1) * 100\n    )\n    .loc[:, ['date_quarter', 'sup']]\n  )\n\n\n\n\nCódigo\nsup\n\n\n\n\n\n\n\n\n\n\ndate_quarter\nsup\n\n\n\n\n0\n2002Q1\n0.580012\n\n\n1\n2002Q2\n0.511528\n\n\n2\n2002Q3\n0.429860\n\n\n3\n2002Q4\n0.369617\n\n\n4\n2003Q1\n0.551338\n\n\n...\n...\n...\n\n\n79\n2021Q4\n0.507757\n\n\n80\n2022Q1\n0.573706\n\n\n81\n2022Q2\n0.510408\n\n\n82\n2022Q3\n0.356714\n\n\n83\n2022Q4\n0.176742\n\n\n\n\n84 rows × 2 columns"
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#juro-real",
    "href": "blog/2024-02-28-curva-is/index.html#juro-real",
    "title": "Como construir uma Curva IS no Python?",
    "section": "2.3 Juro Real",
    "text": "2.3 Juro Real\n\n\nCódigo\n# Cria uma função para a equação de fisher\ndef fisher(juros, inflacao):\n    \"\"\"\n    Calcula a taxa de juros real neutra usando a equação de Fisher.\n\n    Args:\n        juros (float): A taxa de juros nominal em porcentagem (%).\n        inflacao (float): A taxa de inflação em porcentagem (%).\n\n    Returns:\n        float: A taxa de juros real em porcentagem (%).\n\n    Raises:\n        TypeError: Se os argumentos `juros` e `inflacao` não forem do tipo `float`.\n\n    Exemplo:\n        &gt;&gt;&gt; fisher(10, 3)\n        6.796116504854364\n    \"\"\"\n    juros = ((((1 + (juros / 100)) / (1 + inflacao / 100))) -1) * 100\n    return juros\n\n\n\n\nCódigo\n# Taxa referencial - swaps - DI pré-360 dias - média do período (IPEADATA/B3)\nswaps = (\n    ip.timeseries('BMF12_SWAPDI36012')\n    .rename(columns = {'VALUE ((% a.a.))' : 'swaps'})[['swaps']]\n  )\n\n# Muda a coluna de data para o índice\nswaps = swaps.set_index(swaps.index.to_period('M'))\n\nswaps\n\n\n\n\n\n\n\n\n\n\nswaps\n\n\nDATE\n\n\n\n\n\n1999-09\n25.620000\n\n\n1999-10\n25.020000\n\n\n1999-11\n23.790000\n\n\n1999-12\n22.680000\n\n\n2000-01\n21.240000\n\n\n...\n...\n\n\n2023-11\n10.649500\n\n\n2023-12\n10.231053\n\n\n2024-01\n10.046364\n\n\n2024-02\n9.933158\n\n\n2024-03\n9.835500\n\n\n\n\n295 rows × 1 columns\n\n\n\n\n\n\nCódigo\n# Instância a classe de Expectativas\nem = Expectativas()\n\n# Obtém o endpoint da Expectativa de Inflação Acumulada em 12 meses\nexp_ipca_raw = em.get_endpoint('ExpectativasMercadoInflacao12Meses')\n\n# Expectativa média do IPCA - tx. acumulada para os próximos 12 meses (Expectativas)\nipca_expec_12m_raw = (\n    exp_ipca_raw.query()\n    .filter(exp_ipca_raw.Suavizada == 'S',\n            exp_ipca_raw.baseCalculo == 0,\n            exp_ipca_raw.Indicador == 'IPCA')\n    .collect()\n    )\n\n\n\n\nCódigo\n# Muda a classe da coluna de data para date time e period, renomeia as colunas e seleciona a coluna dos valores\nipca_expec_12m = (\n    ipca_expec_12m_raw\n    # altera o tipo da coluna de data para datetime\n    .set_index(pd.to_datetime(ipca_expec_12m_raw['Data'])\n    # altera o tipo da coluna para period\n    .dt.to_period('D'))\n    .resample('M')\n    .agg({'Mediana':'mean'})\n    .rename(columns = {'Mediana' : 'ipca_exp_12m'})\n    .loc[:, ['ipca_exp_12m']]\n  )\n\n\n\n\nCódigo\nipca_expec_12m\n\n\n\n\n\n\n\n\n\n\nipca_exp_12m\n\n\nData\n\n\n\n\n\n2001-12\n5.030000\n\n\n2002-01\n4.733636\n\n\n2002-02\n4.644737\n\n\n2002-03\n4.721500\n\n\n2002-04\n4.790000\n\n\n...\n...\n\n\n2023-12\n3.896605\n\n\n2024-01\n3.862150\n\n\n2024-02\n3.720774\n\n\n2024-03\n3.489515\n\n\n2024-04\n3.502650\n\n\n\n\n269 rows × 1 columns\n\n\n\n\n\n\nCódigo\n# Junta o df do swap e expectativas do ipca\nex_ante = ipca_expec_12m.join(swaps)\n\n# Calcula o juro real ex-ante\nex_ante = ex_ante.assign(juro_real = lambda x: fisher(x.swaps, x.ipca_exp_12m))\n\n# Trimestraliza o juro real\njuro_real =  (\n     ex_ante\n    .assign(date = lambda x: x.index.to_timestamp(),\n            date_quarter = lambda x: pd.PeriodIndex(x['date'], freq = 'Q'))\n    .reset_index()\n    .loc[:, ['date_quarter', 'juro_real']]\n    .groupby(by = 'date_quarter')\n    .agg(juro_real_ex_ante = ('juro_real', 'mean'))\n    .reset_index()\n    )"
  },
  {
    "objectID": "blog/2024-02-28-curva-is/index.html#proxy-juro-neutro",
    "href": "blog/2024-02-28-curva-is/index.html#proxy-juro-neutro",
    "title": "Como construir uma Curva IS no Python?",
    "section": "2.4 Proxy juro neutro",
    "text": "2.4 Proxy juro neutro\n\n\nCódigo\n# Cria função para calcular a data de referência a partir da data de observação\ndef reference_date(date: str):\n    \"\"\"\n    Calcula a data de referência adicionando 3 anos a uma data de observação.\n\n    Args:\n        date (str): Uma string que representa uma data no formato 'YYYY-MM-DD'.\n\n    Returns:\n        List[str]: Uma lista de strings com a data de referência no formato 'YYYY'.\n\n    Raises:\n        TypeError: Se o argumento `date` não for uma string.\n\n    Examples:\n        &gt;&gt;&gt; reference_date('2022-01-01')\n        ['2025']\n    \"\"\"\n    years = pd.DatetimeIndex(date).year.values + 3 # Calcula 3 anos a frente\n    years = years.tolist()\n    years = [str(i) for i in years]\n    return years\n\n\n\n\nCódigo\n# Conecta com a API das Expectativas de Mercado Anuais\nexp_anual = em.get_endpoint('ExpectativasMercadoAnuais')\n\n# Importa as expectativas do IPCA anuais e realiza os filtros\nipca_e_t3_raw = (\n  exp_anual.query()\n  .filter(exp_anual.Indicador == \"IPCA\")\n  .filter(exp_anual.baseCalculo == 0)\n  .select(exp_anual.Data, exp_anual.Mediana, exp_anual.DataReferencia)\n  .collect()\n  )\n\n\n\n\nCódigo\n# Realiza o filtro para a data de referência 3 anos a frente das obs.\nipca_e_t3 = ipca_e_t3_raw[(\n          ipca_e_t3_raw\n          .DataReferencia == reference_date(ipca_e_t3_raw['Data'])\n          )\n            ]\n\n# Renomeia as colunas\nipca_e_t3 = ipca_e_t3.rename(columns = {'Data' : 'date',\n                                  'Mediana' : 'ipca_e'}).drop(['DataReferencia'], axis = 1)\n\n\n\n\nCódigo\n# Importa as expectativas da Selic anuais e realiza os filtros\nselic_e_t3_raw = (\n   exp_anual.query()\n  .filter(exp_anual.Indicador == \"Selic\")\n  .filter(exp_anual.baseCalculo == 0)\n  .select(exp_anual.Data, exp_anual.Mediana, exp_anual.DataReferencia)\n  .collect()\n  )\n\n# Realiza o filtro para a data de referência 3 anos a frente das obs.\nselic_e_t3 = selic_e_t3_raw[(\n    selic_e_t3_raw\n    .DataReferencia == reference_date(selic_e_t3_raw['Data'])\n    )\n      ]\n\n# Renomeia as colunas\nselic_e_t3 = selic_e_t3.rename(columns = {'Data' : 'date',\n                                         'Mediana' : 'selic_e'}).drop(['DataReferencia'], axis = 1)\n\n\n\n\nCódigo\nselic_e_t3\n\n\n\n\n\n\n\n\n\n\ndate\nselic_e\n\n\n\n\n290\n2000-08-07\n10.25\n\n\n294\n2000-08-08\n10.65\n\n\n298\n2000-08-09\n10.65\n\n\n302\n2000-08-10\n10.65\n\n\n306\n2000-08-11\n11.00\n\n\n...\n...\n...\n\n\n29430\n2024-04-08\n8.50\n\n\n29435\n2024-04-09\n8.50\n\n\n29440\n2024-04-10\n8.50\n\n\n29445\n2024-04-11\n8.50\n\n\n29450\n2024-04-12\n8.50\n\n\n\n\n5729 rows × 2 columns\n\n\n\n\n\n\nCódigo\n# Junta os dados em um data frame\nproxy_neutro_m = (\n                pd.merge(left = ipca_e_t3,\n                        right = selic_e_t3,\n                        how = 'inner',\n                        on = 'date')\n                .assign(neutro = lambda x : fisher(x.selic_e, x.ipca_e))\n                )\n\n\n\n\nCódigo\n# Trimestraliza o juro neutro\nproxy_neutro = (\n    proxy_neutro_m\n    .assign(date_quarter = lambda x: pd.PeriodIndex(x['date'], freq = 'Q'))\n    .loc[:, ['date_quarter', 'neutro']]\n    .groupby(by = 'date_quarter')\n    .agg(neutro = ('neutro', 'mean'))\n    .reset_index()\n)\n\nproxy_neutro\n\n\n\n\n\n\n\n\n\n\ndate_quarter\nneutro\n\n\n\n\n0\n2000Q3\n7.900660\n\n\n1\n2000Q4\n8.242186\n\n\n2\n2001Q4\n9.302590\n\n\n3\n2002Q1\n8.374903\n\n\n4\n2002Q2\n8.681850\n\n\n...\n...\n...\n\n\n88\n2023Q2\n4.694520\n\n\n89\n2023Q3\n4.889417\n\n\n90\n2023Q4\n4.830918\n\n\n91\n2024Q1\n4.830918\n\n\n92\n2024Q2\n4.830918\n\n\n\n\n93 rows × 2 columns"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Luiz Henrique",
    "section": "",
    "text": "Ordenar por\n       Pré-selecionado\n         \n          Título\n        \n         \n          Data - Mais velho\n        \n         \n          Data - O mais novo\n        \n         \n          Autor\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n12 minutos\n\n\n\nMacroeconometria\n\n\nMacroeconomia\n\n\nPython\n\n\nPortuguês\n\n\n\nConstruindo um modelo da Curva IS usando o Python\n\n\n\nLuiz Henrique\n\n\n28 de fev. de 2024\n\n\n\n\n\n\n\n\nNenhum item correspondente"
  },
  {
    "objectID": "blog.html#blog",
    "href": "blog.html#blog",
    "title": "Luiz Henrique",
    "section": "",
    "text": "Ordenar por\n       Pré-selecionado\n         \n          Título\n        \n         \n          Data - Mais velho\n        \n         \n          Data - O mais novo\n        \n         \n          Autor\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\n\n12 minutos\n\n\n\nMacroeconometria\n\n\nMacroeconomia\n\n\nPython\n\n\nPortuguês\n\n\n\nConstruindo um modelo da Curva IS usando o Python\n\n\n\nLuiz Henrique\n\n\n28 de fev. de 2024\n\n\n\n\n\n\n\n\nNenhum item correspondente"
  }
]